# 深入理解计算机系统

# 第三章 程序的机器级表示

- 3.58

  对于函数`decode2(long x, long y, long z);`GCC产生的汇编代码如下，尝试写出对应的C代码：

  ```assembly
  sub    %rdx,%rsi
  imulq   %rsi,%rdi
  movq    %rsi,%rax
  shlq    $0x3f,%rax
  sarq    $0x3f,%rax
  xorq    %rdi,%rax
  ret  
  ```

  > 逐语句进行分析：
  >
  > ```assembly
  > # x in %rdi, y in %rsi, z in %rdx
  > sub    %rdx,%rsi		y = y - z
  > imulq   %rsi,%rdi		x = x * y
  > movq    %rsi,%rax		y --> %rax
  > shlq    $0x3f,%rax		%rax << 64
  > sarq    $0x3f,%rax		%rax >> 64
  > xorq    %rdi,%rax		x ^ %rax --> %rax
  > ```
  >
  > 所以我们可以得到对应的函数如下：
  >
  > ```c
  > long decode2(long x, long y, long z) {
  > 	y = y - z;
  >     x = x * y;
  >     return (y << 63 >> 63) ^ x;
  > }
  > ```
  >
  > 我们可以通过gcc和objdump来验证我们的函数是否正确
  >
  > `gcc -Og -c *.c`：其中`-Og`为优化等级，`-c`选项表明只进行编译，结果我们将获得`*.o`的c源文件对应的未进行链接2进制文件。
  >
  > `objdump -d *.o`我们对于可执行的二进制文件，我们可以用这个命令获得二进制文件对应的汇编指令。
  >
  > ![image-20211031205457329](https://gitee.com/chenyuyu118/project-f/raw/master/image/image-20211031205457329.png)

- 3.59 下面代码计算两个64位有符号值x和y的128位乘积，并将结果存在内存中

  ```c
  typedef __int128 int128_t;
  
  void store_prod(int128_t *dest, int64_t x, int64_t y) {
  	*dest = x * (int128_t) y;
  }
  ```

  GCC产生汇编代码如下：

  ```assembly
  store_prob:
  movq    %rdx,%rax
  cqto
  movq    %rsi,%rcx
  sarq    $0x3f,%rcx
  imulq   %rax,%rcx
  imulq   %rsi,%rdx
  add    %rdx,%rcx
  mulq    %rsi
  add    %rcx,%rdx
  mov    %rax,(%rdi)
  mov    %rdx,0x8(%rdi)
  ```

  分析代码是如何进行计算的。

  > |      | %rdi  | %rsi | %rdx                    | %rax      | %rcx         |
  > | ---- | ----- | ---- | ----------------------- | --------- | ------------ |
  > | 起始 | &dest | x    | y                       |           |              |
  > | 2    |       |      |                         | y         |              |
  > | 3    |       |      | yH                      | yL        |              |
  > | 4    |       |      |                         |           | x            |
  > | 5    |       | xL   |                         |           | xH           |
  > | 6    |       |      |                         |           | xH\*yL       |
  > | 7    |       |      | yH\*xL                  |           |              |
  > | 8    |       |      |                         |           | xH*yL+yH\*xL |
  > | 9    |       |      | (yL\*xL)H               | (yL\*xL)L |              |
  > | 10   |       |      | xH\*yL+yH\*xL+(yL\*xL)H |           |              |
  >
  > 最后低位在%rax上，高位在%rdx上。
  >
  > 因为$x = x_H * 2^{64} + x_L$, $y = y_H * 2^{64} + y_L$。
  >
  > 所以$x*y = x_H*y_H*2^{128}+(x_H*y_L+x_L*y_H) * 2^{64} + x_L*y_L$
  >
  > 高位为$x_H*y_L+y_H*x_L+(y_L*x_L)_H$最后补充的部分为进位
  >
  > 低位$(y_L*x_L)_L$
  
- 3.60.考虑下面汇编代码

  ```assembly
  movl    %esi,%ecx
  movl    $0x1,%edx
  movl    $0x0,%eax
  jmp    .L2
  
  .L3:
  movq    %rdi,%r8
  andq    %rdx,%r8
  orq     %r8,%rax
  salq    %cl,%rdx
  
  .L2:
  testq   %rdx,%rdx
  jne    12 <loop+0x12>
  ret    
  ```

  尝试补全线面loop函数：

  ```c
  long loop(long x, int n) {
      long result = _____;
      long mask;
      for (mask = ___; ________; mask = ______) {
          result |= ______;
      }
      return result;
  }
  ```

  > 分析得到代码如下：
  >
  > ```c
  > long loop(long x, int n) {
  >     long result = 0;
  >     long mask;
  >     for (mask = 1; mask != 0; mask = mask << n) {
  >         result |= x & mask;
  >     }
  >     return result;
  > }
  > ```

- 
